<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Magic Tree</title>
    <style>
        /* 基础样式设置 */
        body {
            margin: 0;
            overflow: hidden; /* 隐藏滚动条 */
            background-color: #000000; /* 纯黑背景，增强3D效果的视觉体验 */
            font-family: 'Arial', sans-serif;
        }
        
        /* 3D画布容器样式 */
        #canvas-container {
            width: 100vw;  /* 占满整个视口宽度 */
            height: 100vh; /* 占满整个视口高度 */
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; /* 设置层级，确保3D画布在底层 */
        }
        
        /* 
           【关键修复】 
           不能使用 display: none 或将位置移出屏幕 (-9999px)，
           否则浏览器会暂停视频渲染，导致 MediaPipe 接收不到画面。
           解决方法：放在屏幕内，但设为透明且层级最低。
        */
        #video-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 640px;
            height: 480px;
            opacity: 0;      /* 透明不可见 */
            z-index: -10;    /* 放在最底层 */
            pointer-events: none; /* 禁止鼠标事件 */
        }

        /* 状态提示样式 - 显示系统状态信息 */
        #status-pill {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 8px 16px;
            background: rgba(20, 20, 20, 0.8); /* 半透明黑色背景 */
            border: 1px solid rgba(255, 215, 0, 0.3); /* 金色边框 */
            border-radius: 20px; /* 圆角胶囊形状 */
            color: #FFD700; /* 金色文字 */
            font-size: 13px;
            z-index: 10; /* 置于顶层，确保可见 */
            backdrop-filter: blur(4px); /* 背景模糊效果 */
            transition: all 0.3s; /* 平滑过渡动画 */
        }

        /* 圣诞文字样式 - 节日祝福语 */
        #christmas-text {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5); /* 居中并缩放 */
            font-size: 4rem;
            font-weight: 900;
            color: #FFD700; /* 金色文字 */
            text-shadow: 0 0 20px #FFD700, 0 0 40px #ff4500; /* 发光效果 */
            z-index: 5; /* 置于画布之上，但低于状态提示 */
            opacity: 0; /* 默认隐藏 */
            transition: all 0.4s ease-out; /* 平滑过渡动画 */
            pointer-events: none;
            white-space: nowrap;
            font-family: serif;
        }

        /* 调试点样式 - 用于调试手势识别状态 */
        #debug-dot {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 12px;
            height: 12px;
            background-color: #FFD700; /* 金色圆点 */
            border-radius: 50%; /* 圆形 */
            box-shadow: 0 0 15px #FFD700; /* 发光效果 */
            z-index: 10;
            opacity: 0.1; /* 默认半透明 */
            transition: opacity 0.2s, transform 0.1s; /* 平滑过渡动画 */
        }
        
        /* 媒体查询 - 移动端适配 */
        @media screen and (max-width: 768px) {
            #status-pill {
                font-size: 11px; /* 移动端缩小字体 */
                padding: 6px 12px;
                top: 15px;
                left: 15px;
            }
            
            #christmas-text {
                font-size: 3rem; /* 移动端缩小字体 */
            }
        }
        
        @media screen and (max-width: 480px) {
            #status-pill {
                font-size: 10px;
            }
            
            #christmas-text {
                font-size: 2rem;
            }
        }
    </style>
    
    <!-- 引入必要的库文件 -->
    <!-- Three.js - 3D渲染库 -->
    <script src="./cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe库 - 手势识别功能 -->
    <script src="./cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="./cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="./cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <!-- 状态提示元素 -->
    <div id="status-pill">系统初始化... (请允许摄像头权限)</div>
    <!-- 调试点元素 -->
    <div id="debug-dot"></div>
    <!-- 圣诞文字元素 -->
    <h1 id="christmas-text">MERRY CHRISTMAS</h1>
    
    <!-- 视频输入元素 - 用于手势识别 -->
    <video id="video-input" playsinline></video>
    <!-- 3D画布容器 -->
    <div id="canvas-container"></div>

<script>
    // ================= 配置参数 =================
    // 定义整个应用的关键配置参数，方便统一管理和修改
    const CONFIG = {
        particleCount: 12000,      // 粒子系统中的粒子数量
        particleColor: 0xFFD700,  // 粒子颜色（暖金色）
        bgColor: 0x000000,        // 背景颜色（纯黑色）
        treeLevels: 15,           // 圣诞树的层数
        boxSize: 0.65,            // 礼物盒的基础大小
        particleTreeCount: 2000,  // 单个粒子圣诞树的粒子数量
        surroundingTrees: 6       // 周围粒子圣诞树的数量
    };

    // ================= 工具函数 =================
    // 从Math对象中解构常用的数学方法，提高代码可读性
    const { PI, sin, cos } = Math;
    const TAU = 2 * PI;  // 定义2π常量，常用于极坐标计算
    
    // 将一个值从一个范围映射到另一个范围
    const map = (value, sMin, sMax, dMin, dMax) => {
        return dMin + (value - sMin) / (sMax - sMin) * (dMax - dMin);
    };
    
    // 生成指定范围内的随机浮点数
    const rand = (max, min = 0) => min + Math.random() * (max - min);
    // 生成指定范围内的随机整数
    const randInt = (max, min = 0) => Math.floor(min + Math.random() * (max - min));
    // 将极坐标转换为笛卡尔坐标
    const polar = (ang, r = 1) => [r * cos(ang), r * sin(ang)];

    // ================= 全局变量 =================
    // Three.js核心对象
    let scene, camera, renderer;
    // 圣诞树相关对象
    let giftTreeGroup, starMesh, starGlow;
    // 粒子系统对象
    let particleSystem;
    // 存储礼物盒的原始位置，用于动画效果
    let originalPositions = [];
    
    // 手势相关变量
    let openness = 0;         // 表示手的张开程度（0-1）
    let currentOpenness = 0;  // 当前张开程度的平滑过渡值
    let isHandDetected = false; // 是否检测到手
    
    // 缩放系数，用于移动端适配
    let globalScale = 1;
    let treeScaleFactor = 1;

    // ================= 入口函数 =================
    // 页面加载完成后执行的主函数
    window.onload = function() {
        initThreeJS();       // 初始化Three.js场景
        startCameraApp();    // 启动摄像头和手势识别
        animate();           // 启动动画循环
    };

    // ================= 1. Three.js 场景构建 =================
    /**
     * 初始化Three.js场景，包括创建场景、相机、渲染器、灯光和模型等
     */
    function initThreeJS() {
        // 根据屏幕宽度设置缩放系数
        updateScaleFactors();
        
        // 创建3D场景
        scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.bgColor); // 设置背景颜色为纯黑色
        scene.fog = new THREE.FogExp2(CONFIG.bgColor, 0.02); // 添加黑色雾气效果，增强深度感

        // 创建透视相机
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 25 * globalScale);  // 使用缩放系数调整相机位置
        camera.lookAt(0, 2, 0);         // 设置相机朝向

        // 创建WebGL渲染器，关闭alpha通道以避免背景变白问题
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight); // 设置渲染器大小
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 设置像素比，平衡性能和画质
        document.getElementById('canvas-container').appendChild(renderer.domElement); // 将渲染器添加到DOM

        // 创建环境光 - 提供基础照明
        const ambient = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambient);
        
        // 创建方向光 - 提供主要光源和阴影
        const dirLight = new THREE.DirectionalLight(0xffd700, 1.2); // 暖金色光源
        dirLight.position.set(10, 20, 10); // 设置光源位置
        dirLight.castShadow = true; // 启用阴影
        scene.add(dirLight);

        // 创建场景中的主要元素
        createGiftTree();          // 创建中心礼物树
        createParticles();         // 创建粒子系统
        createSurroundingTrees();  // 创建周围的粒子圣诞树

        // 监听窗口大小变化事件，调整相机和渲染器
        window.addEventListener('resize', () => {
            updateScaleFactors();
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.position.z = 25 * globalScale; // 调整相机Z轴位置以缩放场景
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }
    
    /**
     * 根据窗口宽度更新全局缩放系数
     * 确保在小屏幕上，整体场景会适当缩小，但圣诞树缩小较少
     */
    function updateScaleFactors() {
        // 计算基础缩放系数（基于屏幕宽度）
        globalScale = Math.max(0.8, Math.min(1, window.innerWidth / 1200));
        
        // 计算圣诞树的缩放因子（比全局缩放更小的调整）
        // 在小屏幕上，圣诞树保持相对较大的尺寸
        treeScaleFactor = 1 - (1 - globalScale) * 0.3; // 只应用30%的全局缩放
        
        // 如果存在礼物树组，更新其缩放
        if (giftTreeGroup) {
            giftTreeGroup.scale.set(treeScaleFactor, treeScaleFactor, treeScaleFactor);
        }
    }

    // ================= 礼物树构建 =================
    /**
     * 创建礼物盒的纹理材质
     * @param {number} colorHex - 礼物盒的颜色值（十六进制）
     * @returns {THREE.MeshStandardMaterial} 带有丝带纹理的材质
     */
    function createRibbonTexture(colorHex) {
        // 创建一个画布用于绘制纹理
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        // 绘制礼物盒主体颜色
        ctx.fillStyle = '#' + new THREE.Color(colorHex).getHexString();
        ctx.fillRect(0, 0, 64, 64);
        
        // 绘制金色十字丝带
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(28, 0, 8, 64); // 垂直丝带
        ctx.fillRect(0, 28, 64, 8); // 水平丝带
        
        // 创建并返回材质
        return new THREE.MeshStandardMaterial({ 
            map: new THREE.CanvasTexture(canvas), 
            roughness: 0.4 
        });
    }

    /**
     * 创建由礼物盒组成的圣诞树
     */
    function createGiftTree() {
        // 创建礼物树组，用于统一管理所有礼物盒和星星
        giftTreeGroup = new THREE.Group();
        
        // 定义礼物盒的颜色（红、绿、白、金）
        const colors = [0xB22222, 0x006400, 0xFFFFFF, 0xDAA520];
        // 为每种颜色创建材质
        const materials = colors.map(c => createRibbonTexture(c));
        // 创建礼物盒的几何体
        const geom = new THREE.BoxGeometry(1, 1, 1);

        let y = 0; // 从底部开始堆叠礼物盒
        
        // 循环创建每一层礼物盒
        for(let i=0; i<CONFIG.treeLevels; i++) {
            const p = i/CONFIG.treeLevels;  // 计算当前层级的进度（0-1）
            const r = 4.5 * (1-p) + 0.1;    // 计算当前层级的半径，从底部到顶部逐渐减小
            const s = CONFIG.boxSize * (1 - p*0.3);  // 计算当前层级礼物盒的大小，从底部到顶部逐渐减小
            const count = Math.max(1, Math.floor( (2*Math.PI*r) / (s*1.2) ));  // 计算当前层级需要的礼物盒数量
            
            if(i === CONFIG.treeLevels-1) { 
                // 顶部特殊处理 - 只放一个金色礼物盒
                const box = new THREE.Mesh(geom, materials[3]); 
                box.position.set(0, y, 0);
                box.scale.setScalar(s);
                box.castShadow = true;
                giftTreeGroup.add(box);
            } else {
                // 为每一层创建多个礼物盒，围成一个圆圈
                for(let j=0; j<count; j++) {
                    const ang = (j/count)*Math.PI*2 + i*0.5; // 计算每个礼物盒的角度位置
                    const box = new THREE.Mesh(geom, materials[Math.floor(Math.random()*materials.length)]);
                    // 随机扰动位置，增加自然感
                    box.position.set(
                        Math.cos(ang)*r + (Math.random()-0.5)*1.1, 
                        y, 
                        Math.sin(ang)*r + (Math.random()-0.5)*1.1
                    );
                    // 随机旋转礼物盒
                    box.rotation.set(Math.random()*0.2, ang + Math.random(), Math.random()*0.2);
                    box.scale.setScalar(s);
                    box.castShadow = true;
                    box.receiveShadow = true;
                    giftTreeGroup.add(box);
                    // 存储原始位置，用于后续的炸开动画
                    originalPositions.push({x: box.position.x, z: box.position.z});
                }
            }
            y += s * 0.95; // 更新下一层的Y坐标
        }

        // 创建树顶星星
        const starGeo = new THREE.OctahedronGeometry(0.8, 0); // 使用八面体近似星星形状
        const starMat = new THREE.MeshPhongMaterial({ 
            color: 0xFFFF00, 
            shininess: 100, 
            emissive: 0x404000, 
            specular: 0xFFFFFF 
        }); // 使用Phong材质实现反光效果
        starMesh = new THREE.Mesh(starGeo, starMat);
        starMesh.position.y = y + 0.5; // 放置在树的顶部
        giftTreeGroup.add(starMesh);

        // 创建星星的光晕效果
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64; 
        const ctx = canvas.getContext('2d');
        // 创建径向渐变，从中心的不透明金色到边缘的透明
        const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        grad.addColorStop(0, 'rgba(255,215,0,1)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 64, 64);

        // 创建光晕精灵
        starGlow = new THREE.Sprite(new THREE.SpriteMaterial({
            map: new THREE.CanvasTexture(canvas), 
            color: 0xffaa00, 
            blending: THREE.AdditiveBlending // 使用加法混合，增强发光效果
        }));
        starGlow.scale.set(6, 6, 1); // 设置光晕大小
        starMesh.add(starGlow); // 将光晕添加到星星上

        // 调整整个礼物树的位置，使其居中
        giftTreeGroup.position.y = -y/2;
        scene.add(giftTreeGroup);
    }

    // ================= 暖色粒子系统 =================
    /**
     * 创建漂浮的金色粒子系统
     */
    function createParticles() {
        // 创建粒子几何体
        const geom = new THREE.BufferGeometry();
        const pos = [];    // 存储粒子位置
        const sizes = [];  // 存储粒子大小
        const vels = [];   // 存储粒子速度

        // 生成所有粒子的初始数据
        for(let i=0; i<CONFIG.particleCount; i++) {
            // 随机分布在一个大范围内
            pos.push((Math.random()-0.5)*120);
            pos.push((Math.random()-0.5)*80);
            pos.push((Math.random()-0.5)*80);
            // 随机大小
            sizes.push(Math.random()*0.6 + 0.1);
            // 随机速度
            vels.push(Math.random());
        }

        // 将数据设置到几何体的属性中
        geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geom.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        geom.setAttribute('velocity', new THREE.Float32BufferAttribute(vels, 1));

        // 创建粒子纹理 - 圆形渐变
        const canvas = document.createElement('canvas');
        canvas.width=32; canvas.height=32;
        const ctx=canvas.getContext('2d');
        const g=ctx.createRadialGradient(16,16,0,16,16,16);
        g.addColorStop(0,'rgba(255,255,255,1)');
        g.addColorStop(1,'rgba(0,0,0,0)');
        ctx.fillStyle=g;
        ctx.fillRect(0,0,32,32);

        // 创建粒子材质
        const mat = new THREE.PointsMaterial({
            color: CONFIG.particleColor,    // 使用配置的金色
            size: 0.5,
            map: new THREE.CanvasTexture(canvas),
            transparent: true, 
            opacity: 0.9,
            blending: THREE.AdditiveBlending, // 加法混合，增强发光效果
            depthWrite: false, // 关闭深度写入，避免粒子互相遮挡
            sizeAttenuation: true // 开启大小衰减，远处粒子更小
        });

        // 创建粒子系统并添加到场景
        particleSystem = new THREE.Points(geom, mat);
        scene.add(particleSystem);
    }

    // ================= 2. 手势识别 (修复版) =================
    /**
     * 初始化摄像头和手势识别系统
     */
    function startCameraApp() {
        // 获取DOM元素
        const videoElement = document.getElementById('video-input');
        const statusPill = document.getElementById('status-pill');
        const debugDot = document.getElementById('debug-dot');

        // 创建MediaPipe手势识别实例
        const hands = new Hands({locateFile: (file) => `./cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        // 配置手势识别参数
        hands.setOptions({
            maxNumHands: 1,          // 最多识别一只手
            modelComplexity: 1,      // 使用更复杂的模型，提高准确度
            minDetectionConfidence: 0.5,  // 最小检测置信度
            minTrackingConfidence: 0.5    // 最小跟踪置信度
        });

        // 设置手势识别结果的处理函数
        hands.onResults((results) => {
            // 检查是否检测到手
            if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // 首次检测到手时更新状态
                if(!isHandDetected) {
                    statusPill.innerText = "系统正常：手势已连接";
                    statusPill.style.borderColor = "#00FF00";
                    statusPill.style.color = "#00FF00";
                    debugDot.style.opacity = 1; // 亮起小黄点
                    isHandDetected = true;
                }
                
                // 获取手部关键点数据
                const lm = results.multiHandLandmarks[0];
                // 计算食指(索引8)与拇指(索引4)的距离，用于判断手的张开程度
                const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                
                // 视觉反馈：小黄点随张开程度变大
                debugDot.style.transform = `scale(${1 + dist * 8})`;

                // 将距离映射到0-1范围，表示手的张开程度
                const val = (dist - 0.03) * 6.0;
                openness = Math.max(0, Math.min(1, val)); // 限制在0-1之间
            } else {
                // 未检测到手时更新状态
                if(isHandDetected) {
                    statusPill.innerText = "待机：请在镜头前张开手";
                    statusPill.style.borderColor = "rgba(255, 215, 0, 0.3)";
                    statusPill.style.color = "#FFD700";
                    debugDot.style.opacity = 0.1;
                    isHandDetected = false;
                }
                openness = 0; // 手闭合时将张开程度重置为0
            }
        });

        // 创建摄像头实例
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                // 每一帧都发送视频帧给手势识别系统
                await hands.send({image: videoElement});
            },
            width: 640,  // 设置摄像头分辨率
            height: 480
        });

        // 启动摄像头
        camera.start()
            .then(() => {
                // 成功启动摄像头后更新状态
                statusPill.innerText = "摄像已启动，请展示手势";
            })
            .catch(err => {
                // 启动摄像头失败时显示错误
                console.error(err);
                statusPill.innerText = "错误: 无法访问摄像头";
                statusPill.style.color = "red";
            });
    }

    // ================= 3. 动画循环 =================
    /**
     * 主动画循环函数，负责更新场景中所有元素的状态
     */
    function animate() {
        // 请求下一帧动画
        requestAnimationFrame(animate);
        const time = Date.now() * 0.001; // 获取当前时间，用于动画计算

        // 平滑过渡手的张开程度，避免突变
        currentOpenness += (openness - currentOpenness) * 0.1;

        // 更新礼物树动画
        if(giftTreeGroup) {
            // 基础旋转动画
            giftTreeGroup.rotation.y = time * 0.2;
            
            // 当手张开时，增加额外的动画效果
            if(currentOpenness > 0.1) {
                // 加速旋转
                giftTreeGroup.rotation.y += currentOpenness * 0.3; 
                // 放大圣诞树，考虑treeScaleFactor以保持在小屏幕上的合适尺寸
                const s = treeScaleFactor + currentOpenness * 0.3;
                giftTreeGroup.scale.set(s, s, s);
                
                // 礼物盒炸开效果
                const children = giftTreeGroup.children;
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    // 排除星星和光晕
                    if (child !== starMesh && child !== starGlow) {
                        // 计算礼物盒的偏移量，使其围绕原始位置做周期性运动
                        const offsetX = Math.sin(time + i) * currentOpenness * 0.6;
                        const offsetZ = Math.cos(time + i) * currentOpenness * 0.6;
                        child.position.x = originalPositions[i]?.x + offsetX || 0;
                        child.position.z = originalPositions[i]?.z + offsetZ || 0;
                    }
                }
            } else {
                // 当手闭合时，恢复圣诞树的原始大小和礼物盒位置
                giftTreeGroup.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                
                const children = giftTreeGroup.children;
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    if (child !== starMesh && child !== starGlow && originalPositions[i]) {
                        child.position.x = originalPositions[i].x;
                        child.position.z = originalPositions[i].z;
                    }
                }
            }
        }

        // 更新星星动画
        if(starMesh) {
            // 移除星星自转，保持静止
            // 星星光晕保持固定大小
            starGlow.scale.set(6, 6, 1);
        }

        // 更新粒子系统动画
        if(particleSystem) {
            const pos = particleSystem.geometry.attributes.position.array;
            const vels = particleSystem.geometry.attributes.velocity.array;

            // 更新每个粒子的位置
            for(let i=0; i<pos.length; i+=3) {
                const idx = i/3;
                // 默认情况下粒子向下落
                let vy = -vels[idx] * 0.03; 
                
                // 当手张开时，粒子向上飞升
                if(currentOpenness > 0.1) {
                    vy = vels[idx] * 0.5 * currentOpenness;
                }

                // 更新Y坐标
                pos[i+1] += vy;
                
                // 边界循环处理，粒子超出边界后从另一侧重新进入
                if(pos[i+1] < -40) pos[i+1] = 40;
                if(pos[i+1] > 40) pos[i+1] = -40;
                
                // 左右飘动效果
                pos[i] += Math.sin(time + idx) * 0.015;
            }
            // 标记位置属性需要更新
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        // 更新周围的粒子圣诞树动画
        updateSurroundingTrees(time);

        // 更新圣诞文字显示
        const text = document.getElementById('christmas-text');
        if(currentOpenness > 0.6) {
            // 当手张开到一定程度时显示文字
            text.style.opacity = 1;
            text.style.transform = `translate(-50%, -50%) scale(${1 + currentOpenness * 0.2})`;
        } else {
            // 否则隐藏文字
            text.style.opacity = 0;
            text.style.transform = `translate(-50%, -50%) scale(0.5)`;
        }

        // 渲染场景
        renderer.render(scene, camera);
    }

    // ================= 4. 包裹圣诞树功能 =================
    let surroundingTrees = []; // 存储周围的粒子圣诞树
    let treeUniforms = { time: { type: "f", value: 0.0 } }; // 着色器统一变量，用于传递时间
    
    /**
     * 创建围绕主树的粒子圣诞树
     */
    function createSurroundingTrees() {
        // 创建粒子树组，用于统一管理所有周围的圣诞树
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);
        
        // 设置圣诞树的分布参数
        const baseRadius = 20; // 基础环绕半径
        const radiusVariation = 18; // 半径随机变化范围
        const cameraClearZone = Math.PI / 5; // 相机前方的无树区域（π/4弧度）
        
        // 创建周围的主要粒子圣诞树
        for (let i = 0; i < CONFIG.surroundingTrees + 2; i++) { // 增加2棵树，使分布更密集
            // 计算角度，但避开相机前方区域（正Z轴方向）
            let angle;
            const totalAngles = CONFIG.surroundingTrees + 2;
            const step = Math.PI * 2 / totalAngles;
            
            // 将树木分布在避开相机前方的区域
            if (i < totalAngles / 2) {
                // 左侧区域（-π到-π/4）
                angle = -Math.PI + i * (Math.PI - cameraClearZone) * 2 / totalAngles;
            } else {
                // 右侧区域（π/4到π）
                angle = cameraClearZone + (i - totalAngles/2) * (Math.PI - cameraClearZone) * 2 / totalAngles;
            }
            
            const radius = baseRadius;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            // 创建粒子树
            const tree = createParticleTree(CONFIG.particleTreeCount, [x, 0, z]);
            
            // 保持统一大小
            const scale = 1;
            tree.scale.set(scale, scale, scale);
            
            surroundingTrees.push(tree);
            treeGroup.add(tree);
        }
        
        // 为了增强包裹效果，在上方再添加一些小树
        for (let i = 0; i < 3; i++) {
            // 同样避开相机前方区域
            let angle;
            if (i === 0) angle = -Math.PI / 3; // 左上方
            else if (i === 1) angle = Math.PI; // 正后方
            else angle = Math.PI / 3; // 右上方
            
            const radius = baseRadius * 0.7 + rand(radiusVariation) - radiusVariation/2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            // 创建较小的粒子树
            const tree = createParticleTree(CONFIG.particleTreeCount * 0.7, [x, 5, z]);
            tree.scale.set(0.7, 0.7, 0.7);
            surroundingTrees.push(tree);
            treeGroup.add(tree);
        }
    }
    
    /**
     * 创建单个粒子圣诞树
     * @param {number} totalPoints - 粒子数量
     * @param {Array} treePosition - 树的位置 [x, y, z]
     * @returns {THREE.Points} 粒子树对象
     */
    function createParticleTree(totalPoints, treePosition) {
        // 着色器代码 - 用于粒子树的渲染
        const vertexShader = `
            attribute float mIndex; // 粒子索引，用于动画
            varying vec3 vColor; // 传递颜色到片段着色器
            varying float opacity; // 传递透明度到片段着色器
            uniform float time; // 时间变量，用于动画
            
            float norm(float value, float min, float max) {
                return (value - min) / (max - min);
            }
            
            float map(float value, float sourceMin, float sourceMax, float destMin, float destMax) {
                return destMin + (value - sourceMin) / (sourceMax - sourceMin) * (destMax - destMin);
            }
            
            void main() {
                vColor = color;
                vec3 p = position;
                
                // 添加一些随时间的微小动画，使树看起来在微风中摇曳
                float animation = sin(time * 0.5 + mIndex) * 0.05;
                p.x += animation;
                p.z += animation;
                
                vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
                
                // 根据深度调整粒子大小
                float sizeMapped = map(mvPosition.z, -50.0, 20.0, 1.0, 5.0);
                opacity = map(mvPosition.z, -100.0, 15.0, 0.0, 1.0);
                gl_PointSize = sizeMapped * (100.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        const fragmentShader = `
            varying vec3 vColor; // 从顶点着色器接收颜色
            varying float opacity; // 从顶点着色器接收透明度
            uniform sampler2D pointTexture; // 粒子纹理
            
            void main() {
                gl_FragColor = vec4(vColor, opacity);
                gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
            }
        `;
        
        // 创建着色器材质
        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                ...treeUniforms,
                pointTexture: {
                    value: new THREE.TextureLoader().load('./assets.codepen.io/3685267/spark1.png')
                }
            },
            vertexShader,
            fragmentShader,
            blending: THREE.AdditiveBlending, // 加法混合，增强发光效果
            depthTest: false, // 关闭深度测试，避免粒子互相遮挡
            transparent: true,
            vertexColors: true // 使用顶点颜色
        });
        
        // 创建几何体
        const geometry = new THREE.BufferGeometry();
        const positions = []; // 粒子位置
        const colors = []; // 粒子颜色
        const mIndexs = []; // 粒子索引，用于动画
        const color = new THREE.Color();
        
        // 生成粒子数据
        for (let i = 0; i < totalPoints; i++) {
            const t = Math.random();
            const y = map(t, 0, 1, -4, 7); // 树的高度范围
            // 生成螺旋形的粒子分布
            const ang = map(t, 0, 1, 0, 6 * TAU) + TAU / 2 * (i % 2);
            const [z, x] = polar(ang, map(t, 0, 1, 3, 0)); // 从底部到顶部逐渐变细
            
            // 随机扰动，使树看起来更自然
            const modifier = map(t, 0, 1, 1, 0);
            positions.push(x + rand(-0.2 * modifier, 0.2 * modifier));
            positions.push(y + rand(-0.2 * modifier, 0.2 * modifier));
            positions.push(z + rand(-0.2 * modifier, 0.2 * modifier));
            
            // 设置颜色渐变，从绿色到黄色，模拟圣诞树的色彩分布
            color.setHSL(map(i, 0, totalPoints, 0.3, 0.1), 1.0, 0.5);
            
            colors.push(color.r, color.g, color.b);
            const mIndex = map(i, 0, totalPoints, 1.0, 0.0);
            mIndexs.push(mIndex);
        }
        
        // 设置几何体属性
        geometry.setAttribute(
            'position',
            new THREE.Float32BufferAttribute(positions, 3).setUsage(THREE.DynamicDrawUsage)
        );
        
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('mIndex', new THREE.Float32BufferAttribute(mIndexs, 1));
        
        // 创建粒子树
        const tree = new THREE.Points(geometry, shaderMaterial);
        
        // 设置位置
        const [px, py, pz] = treePosition;
        tree.position.x = px;
        tree.position.y = py;
        tree.position.z = pz;
        
        return tree;
    }
    
    /**
     * 更新周围圣诞树的动画
     * @param {number} time - 当前时间
     */
    function updateSurroundingTrees(time) {
        // 更新uniforms中的时间，用于着色器动画
        treeUniforms.time.value = time;
        
        // 为每棵树添加旋转动画，使其更有活力
        surroundingTrees.forEach((tree, index) => {
            // 每棵树有略微不同的旋转速度，创造更自然的效果
            const speed = 0.1 + (index % 3) * 0.05;
            tree.rotation.y = time * speed;
            
            // 保持统一大小
            tree.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
        });
    }
</script>
</body>
</html>
